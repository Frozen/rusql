// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use super::definitions::*;
use self::ParseResult::{Matched, Failed};
enum ParseResult<T> { Matched(uint, T), Failed, }
struct ParseState {
    max_err_pos: uint,
    expected: ::std::collections::HashSet<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),}
    }
    fn mark_failure(&mut self, pos: uint, expected: &'static str)
     -> ParseResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: uint, m: &'static str)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           input.as_bytes().slice(pos, pos + l) == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn any_char(input: &str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        Matched(input.char_range_at(pos).next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: uint) -> (uint, uint) {
    let mut remaining = pos;
    let mut lineno: uint = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
fn parse_rusql_stmt<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<RusqlStatement> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_whitespace(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_alter_table_stmt(input, state, pos);
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let seq_res =
                                                parse_whitespace(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_semicolon(input,
                                                                            state,
                                                                            pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        input.slice(start_pos,
                                                                                    pos);
                                                                    Matched(pos,
                                                                            {
                                                                                s
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_whitespace(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_create_table_stmt(input,
                                                                    state,
                                                                    pos);
                                        match seq_res {
                                            Matched(pos, s) => {
                                                {
                                                    let seq_res =
                                                        parse_whitespace(input,
                                                                         state,
                                                                         pos);
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let seq_res =
                                                                    parse_semicolon(input,
                                                                                    state,
                                                                                    pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                input.slice(start_pos,
                                                                                            pos);
                                                                            Matched(pos,
                                                                                    {
                                                                                        s
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_whitespace(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_drop_table_stmt(input,
                                                                          state,
                                                                          pos);
                                                match seq_res {
                                                    Matched(pos, s) => {
                                                        {
                                                            let seq_res =
                                                                parse_whitespace(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_semicolon(input,
                                                                                            state,
                                                                                            pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                s
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_whitespace(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_insert_stmt(input,
                                                                              state,
                                                                              pos);
                                                        match seq_res {
                                                            Matched(pos, s) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_whitespace(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_semicolon(input,
                                                                                                    state,
                                                                                                    pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let match_str =
                                                                                                input.slice(start_pos,
                                                                                                            pos);
                                                                                            Matched(pos,
                                                                                                    {
                                                                                                        s
                                                                                                    })
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_whitespace(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_select_stmt(input,
                                                                              state,
                                                                              pos);
                                                        match seq_res {
                                                            Matched(pos, s) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_whitespace(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_semicolon(input,
                                                                                                    state,
                                                                                                    pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let match_str =
                                                                                                input.slice(start_pos,
                                                                                                            pos);
                                                                                            Matched(pos,
                                                                                                    {
                                                                                                        s
                                                                                                    })
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_rusql_parse<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<Vec<RusqlStatement>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let pos =
                if repeat_value.len() > 0 {
                    let sep_res = parse_whitespace(input, state, pos);
                    match sep_res {
                        Matched(newpos, _) => { newpos }
                        Failed => break ,
                    }
                } else { pos };
            let step_res = parse_rusql_stmt(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1u {
            Matched(repeat_pos, repeat_value)
        } else { Failed }
    }
}
fn parse_alter_table_stmt<'input>(input: &'input str, state: &mut ParseState,
                                  pos: uint) -> ParseResult<RusqlStatement> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_ALTER(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_TABLE(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_table_name(input, state, pos);
                                    match seq_res {
                                        Matched(pos, n) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let choice_res =
                                                            parse_rename_to(input,
                                                                            state,
                                                                            pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_add_column(input,
                                                                             state,
                                                                             pos),
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, a) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        let def =
                                                                            AlterTableDef{name:
                                                                                              n,
                                                                                          mode:
                                                                                              a,};
                                                                        RusqlStatement::AlterTable(def)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rename_to<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<AlterTable> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_RENAME(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_TO(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_table_name(input, state, pos);
                                    match seq_res {
                                        Matched(pos, n) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            AlterTable::RenameTo(n)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_add_column<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<AlterTable> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_ADD(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match parse_COLUMN(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_column_def(input, state, pos);
                                    match seq_res {
                                        Matched(pos, c) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            AlterTable::AddColumn(c)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_create_table_stmt<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<RusqlStatement> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_CREATE(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_TABLE(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_table_name(input, state, pos);
                                    match seq_res {
                                        Matched(pos, n) => {
                                            {
                                                let seq_res =
                                                    parse_whitespace(input,
                                                                     state,
                                                                     pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_lparen(input,
                                                                             state,
                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            {
                                                                                let mut repeat_pos =
                                                                                    pos;
                                                                                let mut repeat_value =
                                                                                    vec!();
                                                                                loop 
                                                                                     {
                                                                                    let pos =
                                                                                        repeat_pos;
                                                                                    let pos =
                                                                                        if repeat_value.len()
                                                                                               >
                                                                                               0
                                                                                           {
                                                                                            let sep_res =
                                                                                                parse_comma(input,
                                                                                                            state,
                                                                                                            pos);
                                                                                            match sep_res
                                                                                                {
                                                                                                Matched(newpos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    newpos
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                break
                                                                                                    ,
                                                                                            }
                                                                                        } else {
                                                                                            pos
                                                                                        };
                                                                                    let step_res =
                                                                                        parse_column_def(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                    match step_res
                                                                                        {
                                                                                        Matched(newpos,
                                                                                                value)
                                                                                        =>
                                                                                        {
                                                                                            repeat_pos
                                                                                                =
                                                                                                newpos;
                                                                                            repeat_value.push(value);
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        {
                                                                                            break
                                                                                                ;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if repeat_value.len()
                                                                                       >=
                                                                                       1u
                                                                                   {
                                                                                    Matched(repeat_pos,
                                                                                            repeat_value)
                                                                                } else {
                                                                                    Failed
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    c)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_rparen(input,
                                                                                                     state,
                                                                                                     pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    input.slice(start_pos,
                                                                                                                pos);
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            let def =
                                                                                                                TableDef{table_name:
                                                                                                                             n,
                                                                                                                         columns:
                                                                                                                             c,};
                                                                                                            RusqlStatement::CreateTable(def)
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_column_def<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<ColumnDef> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_column_name(input, state, pos);
            match seq_res {
                Matched(pos, n) => {
                    {
                        let seq_res =
                            match parse_type_name(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, t) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_column_constraint(input,
                                                                            state,
                                                                            pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, c) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            ColumnDef{name: n,
                                                                      column_type:
                                                                          t,
                                                                      column_constraints:
                                                                          c,}
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_column_constraint<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint)
 -> ParseResult<ColumnConstraint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                match {
                          let seq_res = parse_CONSTRAINT(input, state, pos);
                          match seq_res {
                              Matched(pos, _) => {
                                  parse_name(input, state, pos)
                              }
                              Failed => Failed,
                          }
                      } {
                    Matched(newpos, value) => { Matched(newpos, Some(value)) }
                    Failed => { Matched(pos, None) }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let seq_res =
                                    parse_PRIMARY(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        parse_KEY(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            { ColumnConstraint::PrimaryKey })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_drop_table_stmt<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<RusqlStatement> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_DROP(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_TABLE(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_table_name(input, state, pos);
                                    match seq_res {
                                        Matched(pos, n) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            let def =
                                                                DropTableDef{name:
                                                                                 n,};
                                                            RusqlStatement::DropTable(def)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_insert_stmt<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<RusqlStatement> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_INSERT(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_INTO(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_table_name(input, state, pos);
                                    match seq_res {
                                        Matched(pos, n) => {
                                            {
                                                let seq_res =
                                                    match parse_insert_column_name(input,
                                                                                   state,
                                                                                   pos)
                                                        {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, cn) => {
                                                        {
                                                            let seq_res =
                                                                parse_VALUES(input,
                                                                             state,
                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            {
                                                                                let mut repeat_pos =
                                                                                    pos;
                                                                                let mut repeat_value =
                                                                                    vec!();
                                                                                loop 
                                                                                     {
                                                                                    let pos =
                                                                                        repeat_pos;
                                                                                    let pos =
                                                                                        if repeat_value.len()
                                                                                               >
                                                                                               0
                                                                                           {
                                                                                            let sep_res =
                                                                                                parse_comma(input,
                                                                                                            state,
                                                                                                            pos);
                                                                                            match sep_res
                                                                                                {
                                                                                                Matched(newpos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    newpos
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                break
                                                                                                    ,
                                                                                            }
                                                                                        } else {
                                                                                            pos
                                                                                        };
                                                                                    let step_res =
                                                                                        parse_insert_values(input,
                                                                                                            state,
                                                                                                            pos);
                                                                                    match step_res
                                                                                        {
                                                                                        Matched(newpos,
                                                                                                value)
                                                                                        =>
                                                                                        {
                                                                                            repeat_pos
                                                                                                =
                                                                                                newpos;
                                                                                            repeat_value.push(value);
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        {
                                                                                            break
                                                                                                ;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if repeat_value.len()
                                                                                       >=
                                                                                       1u
                                                                                   {
                                                                                    Matched(repeat_pos,
                                                                                            repeat_value)
                                                                                } else {
                                                                                    Failed
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    v)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                let def =
                                                                                                    InsertDef{table_name:
                                                                                                                  n,
                                                                                                              column_names:
                                                                                                                  cn,
                                                                                                              column_data:
                                                                                                                  v,};
                                                                                                RusqlStatement::Insert(def)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_insert_column_name<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint)
 -> ParseResult<Vec<String>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_whitespace(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_lparen(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let pos =
                                                    if repeat_value.len() > 0
                                                       {
                                                        let sep_res =
                                                            parse_comma(input,
                                                                        state,
                                                                        pos);
                                                        match sep_res {
                                                            Matched(newpos, _)
                                                            => {
                                                                newpos
                                                            }
                                                            Failed => break ,
                                                        }
                                                    } else { pos };
                                                let step_res =
                                                    parse_column_name(input,
                                                                      state,
                                                                      pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 1u {
                                                Matched(repeat_pos,
                                                        repeat_value)
                                            } else { Failed }
                                        };
                                    match seq_res {
                                        Matched(pos, s) => {
                                            {
                                                let seq_res =
                                                    parse_rparen(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    { s })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_insert_values<'input>(input: &'input str, state: &mut ParseState,
                               pos: uint) -> ParseResult<Vec<LiteralValue>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_whitespace(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_lparen(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let pos =
                                                    if repeat_value.len() > 0
                                                       {
                                                        let sep_res =
                                                            parse_comma(input,
                                                                        state,
                                                                        pos);
                                                        match sep_res {
                                                            Matched(newpos, _)
                                                            => {
                                                                newpos
                                                            }
                                                            Failed => break ,
                                                        }
                                                    } else { pos };
                                                let step_res =
                                                    parse_literal_value(input,
                                                                        state,
                                                                        pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 1u {
                                                Matched(repeat_pos,
                                                        repeat_value)
                                            } else { Failed }
                                        };
                                    match seq_res {
                                        Matched(pos, l) => {
                                            {
                                                let seq_res =
                                                    parse_rparen(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    { l })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_select_stmt<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<RusqlStatement> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_SELECT(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_result_column(input, state, pos);
                        match seq_res {
                            Matched(pos, r) => {
                                {
                                    let seq_res =
                                        parse_FROM(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let mut repeat_pos =
                                                            pos;
                                                        let mut repeat_value =
                                                            vec!();
                                                        loop  {
                                                            let pos =
                                                                repeat_pos;
                                                            let pos =
                                                                if repeat_value.len()
                                                                       > 0 {
                                                                    let sep_res =
                                                                        parse_comma(input,
                                                                                    state,
                                                                                    pos);
                                                                    match sep_res
                                                                        {
                                                                        Matched(newpos,
                                                                                _)
                                                                        => {
                                                                            newpos
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        break
                                                                            ,
                                                                    }
                                                                } else {
                                                                    pos
                                                                };
                                                            let step_res =
                                                                parse_table_or_subquery(input,
                                                                                        state,
                                                                                        pos);
                                                            match step_res {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    repeat_pos
                                                                        =
                                                                        newpos;
                                                                    repeat_value.push(value);
                                                                }
                                                                Failed => {
                                                                    break ;
                                                                }
                                                            }
                                                        }
                                                        if repeat_value.len()
                                                               >= 1u {
                                                            Matched(repeat_pos,
                                                                    repeat_value)
                                                        } else { Failed }
                                                    };
                                                match seq_res {
                                                    Matched(pos, t) => {
                                                        {
                                                            let seq_res =
                                                                match parse_where_expr(input,
                                                                                       state,
                                                                                       pos)
                                                                    {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        w) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Matched(pos,
                                                                                {
                                                                                    let def =
                                                                                        SelectDef{result_column:
                                                                                                      r,
                                                                                                  table_or_subquery:
                                                                                                      t,
                                                                                                  where_expr:
                                                                                                      w,};
                                                                                    RusqlStatement::Select(def)
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_result_column<'input>(input: &'input str, state: &mut ParseState,
                               pos: uint) -> ParseResult<ResultColumn> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_whitespace1(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_asterisk(input, state, pos);
                        match seq_res {
                            Matched(pos, a) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { ResultColumn::Asterisk })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_table_or_subquery<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<String> {
    parse_table_name(input, state, pos)
}
fn parse_where_expr<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<Expression> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_WHERE(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_whitespace1(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_expr(input, state, pos);
                                    match seq_res {
                                        Matched(pos, e) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos, { e })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_value<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Expression> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_literal_value(input, state, pos);
                    match seq_res {
                        Matched(pos, l) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos, { Expression::LiteralValue(l) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_column_name(input, state, pos);
                    match seq_res {
                        Matched(pos, n) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos, { Expression::ColumnName(n) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_expr<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Expression> {
    {
        let seq_res = parse_whitespace(input, state, pos);
        match seq_res {
            Matched(pos, _) => {
                {
                    let choice_res =
                        {
                            let start_pos = pos;
                            {
                                let seq_res = parse_value(input, state, pos);
                                match seq_res {
                                    Matched(pos, e1) => {
                                        {
                                            let seq_res =
                                                parse_binary_operator(input,
                                                                      state,
                                                                      pos);
                                            match seq_res {
                                                Matched(pos, b) => {
                                                    {
                                                        let seq_res =
                                                            parse_expr(input,
                                                                       state,
                                                                       pos);
                                                        match seq_res {
                                                            Matched(pos, e2)
                                                            => {
                                                                {
                                                                    let match_str =
                                                                        input.slice(start_pos,
                                                                                    pos);
                                                                    Matched(pos,
                                                                            {
                                                                                Expression::BinaryOperator((b,
                                                                                                            box() e1,
                                                                                                            box() e2))
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        };
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let start_pos = pos;
                            {
                                let seq_res = parse_value(input, state, pos);
                                match seq_res {
                                    Matched(pos, v) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { v })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_whitespace<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                if input.len() > pos {
                    let ::std::str::CharRange { ch, next } =
                        input.char_range_at(pos);
                    match ch {
                        ' ' | '\t' | '\n' | '\r' => Matched(next, ()),
                        _ => state.mark_failure(pos, "[ \t\n\r]"),
                    }
                } else { state.mark_failure(pos, "[ \t\n\r]") };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_whitespace1<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<()> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res =
                if input.len() > pos {
                    let ::std::str::CharRange { ch, next } =
                        input.char_range_at(pos);
                    match ch {
                        ' ' | '\t' | '\n' | '\r' => Matched(next, ()),
                        _ => state.mark_failure(pos, "[ \t\n\r]"),
                    }
                } else { state.mark_failure(pos, "[ \t\n\r]") };
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1u {
            Matched(repeat_pos, ())
        } else { Failed }
    }
}
fn parse_semicolon<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<()> {
    slice_eq(input, state, pos, ";")
}
fn parse_lparen<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    slice_eq(input, state, pos, "(")
}
fn parse_rparen<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    slice_eq(input, state, pos, ")")
}
fn parse_comma<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    slice_eq(input, state, pos, ",")
}
fn parse_asterisk<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<()> {
    slice_eq(input, state, pos, "*")
}
fn parse_equals<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    slice_eq(input, state, pos, "=")
}
fn parse_equals2<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    slice_eq(input, state, pos, "==")
}
fn parse_string_literal<'input>(input: &'input str, state: &mut ParseState,
                                pos: uint) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_string(input, state, pos);
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos, { s })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let choice_res =
                                    parse_escape_char(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    if input.len() > pos {
                                        let ::std::str::CharRange { ch, next
                                                } = input.char_range_at(pos);
                                        match ch {
                                            '\"' =>
                                            state.mark_failure(pos, "[\"]"),
                                            _ => Matched(next, ()),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[\"]")
                                    },
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_escape_char<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "\\");
        match seq_res {
            Matched(pos, _) => { any_char(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_ALTER<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "ALTER") }
            Failed => Failed,
        }
    }
}
fn parse_CREATE<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "CREATE") }
            Failed => Failed,
        }
    }
}
fn parse_DROP<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "DROP") }
            Failed => Failed,
        }
    }
}
fn parse_INSERT<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "INSERT") }
            Failed => Failed,
        }
    }
}
fn parse_SELECT<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "SELECT") }
            Failed => Failed,
        }
    }
}
fn parse_ADD<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "ADD") }
            Failed => Failed,
        }
    }
}
fn parse_COLUMN<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "COLUMN") }
            Failed => Failed,
        }
    }
}
fn parse_CONSTRAINT<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "CONSTRAINT") }
            Failed => Failed,
        }
    }
}
fn parse_FROM<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "FROM") }
            Failed => Failed,
        }
    }
}
fn parse_TABLE<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "TABLE") }
            Failed => Failed,
        }
    }
}
fn parse_INTEGER<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "INTEGER") }
            Failed => Failed,
        }
    }
}
fn parse_INTO<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "INTO") }
            Failed => Failed,
        }
    }
}
fn parse_KEY<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "KEY") }
            Failed => Failed,
        }
    }
}
fn parse_PRIMARY<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "PRIMARY") }
            Failed => Failed,
        }
    }
}
fn parse_RENAME<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "RENAME") }
            Failed => Failed,
        }
    }
}
fn parse_TEXT<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "TEXT") }
            Failed => Failed,
        }
    }
}
fn parse_TO<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "TO") }
            Failed => Failed,
        }
    }
}
fn parse_VALUES<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "VALUES") }
            Failed => Failed,
        }
    }
}
fn parse_WHERE<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = parse_whitespace1(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "WHERE") }
            Failed => Failed,
        }
    }
}
fn parse_nws_name<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let ::std::str::CharRange { ch, next } =
                                    input.char_range_at(pos);
                                match ch {
                                    'A' ...'Z' | 'a' ...'z' | '0' ...'9' | '_'
                                    => Matched(next, ()),
                                    _ =>
                                    state.mark_failure(pos, "[A-Za-z0-9_]"),
                                }
                            } else {
                                state.mark_failure(pos, "[A-Za-z0-9_]")
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1u {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_name<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_whitespace1(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_nws_name(input, state, pos);
                        match seq_res {
                            Matched(pos, n) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { n })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_table_name<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<String> {
    parse_name(input, state, pos)
}
fn parse_column_name<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_whitespace(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_nws_name(input, state, pos);
                        match seq_res {
                            Matched(pos, n) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { n })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_type_name<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<ColumnType> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_INTEGER(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos, { ColumnType::Integer })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_TEXT(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos, { ColumnType::Text })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_literal_value<'input>(input: &'input str, state: &mut ParseState,
                               pos: uint) -> ParseResult<LiteralValue> {
    {
        let choice_res =
            {
                let seq_res = parse_whitespace(input, state, pos);
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let start_pos = pos;
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                if input.len() > pos {
                                                    let ::std::str::CharRange {
                                                            ch, next } =
                                                        input.char_range_at(pos);
                                                    match ch {
                                                        '0' ...'9' =>
                                                        Matched(next, ()),
                                                        _ =>
                                                        state.mark_failure(pos,
                                                                           "[0-9]"),
                                                    }
                                                } else {
                                                    state.mark_failure(pos,
                                                                       "[0-9]")
                                                };
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        if repeat_value.len() >= 1u {
                                            Matched(repeat_pos, ())
                                        } else { Failed }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos,
                                                    {
                                                        LiteralValue::Integer(match_str.parse::<int>().unwrap())
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                    Failed => Failed,
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let seq_res = parse_whitespace(input, state, pos);
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let start_pos = pos;
                            {
                                let seq_res =
                                    parse_string_literal(input, state, pos);
                                match seq_res {
                                    Matched(pos, s) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos,
                                                    { LiteralValue::Text(s) })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}
fn parse_binary_operator<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<BinaryOperator> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_equals(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_equals2(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { BinaryOperator::Equals })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
pub fn rusql_stmt<'input>(input: &'input str)
 -> Result<RusqlStatement, String> {
    let mut state = ParseState::new();
    match parse_rusql_stmt(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let expected = state.expected.to_string().escape_default();
    Err(format!("Error at {}: Expected {}" , pos_to_line (
                input , state . max_err_pos ) , expected))
}
pub fn rusql_parse<'input>(input: &'input str)
 -> Result<Vec<RusqlStatement>, String> {
    let mut state = ParseState::new();
    match parse_rusql_parse(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let expected = state.expected.to_string().escape_default();
    Err(format!("Error at {}: Expected {}" , pos_to_line (
                input , state . max_err_pos ) , expected))
}
